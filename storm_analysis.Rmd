---
title: "Analysis of the Effects of Storms on Population Health"
author: "Peter W Setter"
date: "March 6, 2015"
output:
  html_document:
    keep_md: yes
---

### Synopsis


### Questions
Across the United States, which types of events (as indicated in the EVTYPE variable) are most harmful with respect to population health?

Across the United States, which types of events have the greatest economic consequences?

### Hardware and Software Used
This analysis used a Macbook 2,1 running OSX 10.6.8 with a Intel Core 2 Duo processor and 2 GB of RAM. The software was R 3.1.2 run within RStudio Version 0.98.1087. 

### Data Processing
```{r}
library(R.utils)
library(dplyr)
library(lubridate)
library(stringr)
library(choroplethr)
library(datasets)
```

```{r, cache=TRUE}

storm.data.url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
download.file(storm.data.url, destfile = "StormData.csv.bz2", method = "curl")
Sys.time() # Time of downloading data
bunzip2(filename = "StormData.csv.bz2", overwrite = TRUE)
storm.data <- tbl_df(read.csv("StormData.csv", header=TRUE))
```

With the data load, my next steps will involve cleaning and tidying it. I'll start with several basic tasks:

* Turn all the `EVTYPE` factors to lower case
* Convert the `BGN_DATE` from a factor into `POSIXct` format
* Create `prop.dmg`, which multiplies `PROPDMG` by `PROPDMGEXP` to give the property damage in dollars (This ensures the variable is in one column rather than two)
* Create `crop.dmg`, which multiples `CROPDMG` by `CROPDMGEXP` to give the property damage in dollars (Again, isolating the variable to one column)
* Selecting the columns of interest for this study -- date, state, injuries, fatalities, and damage costs -- while tidying the column names by changing them to lower case
* Filtering the results for events in 1996 and later

The final step was performed because the data prior to this date is (more complete)[https://class.coursera.org/repdata-012/forum/thread?thread_id=29#comment-28]. Given the size of storm.data, we will remove it to free up resources.

```{r}
storm.data2 <- storm.data %>%  
        mutate(event = tolower(EVTYPE), 
               date = mdy_hms(BGN_DATE),
               prop.dmg = ifelse(PROPDMGEXP == 'K', PROPDMG*1000,
                                  ifelse(PROPDMGEXP == 'M', PROPDMG*1e6,
                                        ifelse(PROPDMGEXP == 'B', PROPDMG*1e9, 0))),
               crop.dmg = ifelse(CROPDMGEXP == 'K', CROPDMG*1000,
                                  ifelse(CROPDMGEXP == 'M', CROPDMG*1e6,
                                        ifelse(CROPDMGEXP == 'B', CROPDMG*1e9, 0)))) %>% 
        select(date, event, state = STATE, fatalities = FATALITIES, 
               injuries = INJURIES, prop.dmg, crop.dmg) %>% 
        filter(date > ymd('1995-12-31'))
rm(storm.data)
```

Looking at the structure of `storm.data2` we see that there are many more events in the data set than the 48 mentioned in the documentation. 

```{r}
str(storm.data2)
```

The next task will be to clean the data by combing factors so they fall within the permitted categories. If the listing is unknown or difficult to determine, it will be placed in the category `other`. `Combine.events` is a function that returns a permitted event name based on on an `event`. By coupling `any` with `str_detect`, we can look for abbreviations and misspellings, e.g. "tstm" for "thunderstorm" and "wnd" for "wind".

Overview on how labels were combined:

* Marine events were classified first in order to avoid misclassification
* Snow squalls were classified as `winter.storm`
* Heavy or "record" snow was classified `heavy.snow`
* All other snow events, along with other winter precipiation, were classified as `winter.weather`
* "Glaze" and "black ice" were classified as `frost.freeze`
* Remnants of hurricanes were classified as `tropical.depression`
* Any event labeled with surf or sea was classified as `high.surf`
* Whirlwinds and wall clouds were grouped within `funnel.cloud` since they are related weather events
* Unless specificed as costal, lake, or flash, all any label containing "flood" was classified as a `flood`
* As per the documentation, all land- and mudslides were classified as `debris.flow`
* If a event labeled included "extreme", "record", "excessive", "extended", or "hypothermia", is was classified as `extreme.cold.wind.chill`
* Other cold, chill, and cool events were classified as `cold.wind.chill`
* Similarly, when "excessive" or "record" were coupled with a synonym for "hot", it was classified as `excessive.heat` otherwise it was simply `heat`
* "Dry" and "low rain" were classified as `drought`
* All fires were classified as `wildfire`

With the function defined, I first create a data frame tbl called `storm.clean`. I utilize vapply to overwrite the `event` with each `event` properly classified. Please see this [StackOverflow post](http://stackoverflow.com/questions/9668456/why-does-sapply-return-a-list) for an explanation on the use of vapply. Last, the `event` column is transformed from `character`s into `factor`s.

```{r, cache=TRUE}
Combine.events <- function(event) {
        if(str_detect(event, 'marine')) {
                if (any(str_detect(event, c('tstm', 'thunderstorm')))) {
                        return('marine.thunderstorm.wind')
                } else if (str_detect(event, 'hail')) {
                        return('marine.hail')
                } else if (str_detect(event, 'high')) {
                        return('marine.high.wind')
                } else if (str_detect(event, 'strong')) {
                        return('marine.strong.wind')
                } else {
                        return('other')
                }
        } else if (any(str_detect(event, 
                        c('winter storm', 'snow squall')))) {
                return('winter.storm')
        } else if (any(str_detect(event, c('flurries', 'icy', 'mixed', 'ic. road', 'freezing', 'wintry')))) {
                return('winter.weather')
        } else if (str_detect(event, 'ice storm')) {
                return('ice.storm')      
        } else if (str_detect(event, 'sleet')) {
                return('sleet')
        } else if (str_detect(event, 'snow')) {
                if (any(str_detect(event, c('heavy', 'record')))) {
                        return('heavy.snow')
                } else if (str_detect(event, 'lake')) {
                        return('lake.effect.snow')
                } else {
                        return('winter.weather')
                }
        } else if (str_detect(event, 'blizzard')) {
                return('blizzard')
        } else if (any(str_detect(event, 
                        c('freeze', 'frost', 'glaze', 'black ice')))) {
                return('frost.freeze')
        } else if (any(str_detect(event, c('tropical', 'remnant')))) {
                if (str_detect(event, 'storm')) {
                        return('tropical.storm')
                } else {
                        return('tropical.depression')
                }
        } else if (any(str_detect(event, c('hurricane', 'typhoon')))) {
                return('hurricane.typhoon')
        } else if (any(str_detect(event, c('surf', 'sea')))) {
                return('high.surf')
        } else if (str_detect(event, 'tsunami')) {
                return('tsunami')
        } else if (str_detect(event, 'tornado')) {
                return('tornado')       
        } else if (str_detect(event, 'spout')) {
                return('waterspout')
        } else if (any(str_detect(event, c('funnel', 'whirl', 'wall')))) {
                return('funnel.cloud')
        } else if (any(str_detect(event, c('hail', 'ice pellet')))) {
                return('hail')
        } else if (any(str_detect(event, c('flood', 'fld', 'beach', 'jam')))) {
                if (any(str_detect(event, c('costal', 'cstl', 'tidal', 'beach')))) {
                        return('costal.flood')
                } else if (str_detect(event, 'flash')) {
                        return('flash.flood')
                } else if (str_detect(event, 'lake')) {
                        return('lakeshore.flood')
                } else {
                        return('flood')
                }
        } else if (any(str_detect(event, c('slide', 'slump')))) {
                return('debris.flow')
        } else if (any(str_detect(event, c('cold', 'chill', 'cool')))) {
                if (any(str_detect(event, 
                        c('extreme', 'record', 'excessive', 
                          'extended', 'thermia')))) {
                        return('extreme.cold.wind.chill')
                } else {
                        return('cold.wind.chill')
                }
        } else if (any(str_detect(event, c('heat', 'warm', 'high temp', 'hot')))) {
                if(any(str_detect(event, c('excessive', 'record')))) {
                        return('excessive.heat')
                } else {
                        return('heat')
                }
        } else if (any(str_detect(event, c('lightning','lighting')))) {
                return('lightning')
        } else if (str_detect(event, 'avalanc')) {
                return('avalanche')
        } else if (str_detect(event, 'rip')) {
                return('rip.current')
        } else if (str_detect(event, 'surge')) {
                return('storm.surge')
        } else if (any(str_detect(event, 
                        c('drought', 'record dry', 'hot and dry', 
                          'dry spell', 'low rain')))) {
                return('drought')
        } else if (str_detect(event, 'fire')) {
                return('wildfire')
        } else if (str_detect(event, 'dust')) {
                if (str_detect(event, 'dev.l')) {
                        return('dust.devil')
                } else {
                        return('dust.storm')
                }
        } else if (any(str_detect(event, c('wind', 'wnd', 'burst')))) {
                if(any(str_detect(event, c('tstm', 'thunderstorm', 'burst')))
                   & !str_detect(event, 'non')) {
                        return('thunderstorm.wind')
                } else if (str_detect(event, 'high')) {
                        return('high.wind')
                } else {
                        return('strong.wind')
                } 
        } else if (any(str_detect(event, c('fog', 'vog')))) {
                if (any(str_detect(event, c('freezing', 'ice')))) {
                        return('freezing.fog')
                } else {
                        return('dense.fog')
                }
        } else if (str_detect(event, 'smoke')) {
                return('dense.smoke')
        } else if (str_detect(event, 'volcan')) {
                return('volcanic.ash')
        } else if (any(str_detect(event, 
                        c('rain', 'thunderstorms', 'coastal storm', 
                          'wet', 'tstm', 'precipitaiton')))) {
                return('heavy.rain')
        } else if (any(str_detect(event, c('blow-out', 'astronomical low')))) {
                return('astronomical.low.tide')
        } else if (any(str_detect(event, c('swell', 'seiche', 'wave')))) {
                return('seiche')
        } else {
                return('other')
        }
}

storm.clean <- storm.data2
storm.clean$event <- vapply(storm.clean$event, Combine.events, character(1))
storm.clean$event <- as.factor(storm.clean$event)
```

If we examine the head of the data frame tbl, I notice that there are several entries that have the same `date`, `event`, and `state`. (Also, since storm.data2 is no longer needed, it is removed to free up space.)

```{r}
rm(storm.data2)
head(storm.clean)
```

Large events can affect sevearl parts of a state or multiple states. Each county or region may report separately. To best understand each event, I can group the data by `date`, `event`, and `state`, and then report the the total property damage, the total crop damage, the total damage, total fatalities, and total injuries. I chose to group by state, because diaster relief is typically performed at the state level with potential federal support. The resulting data frame tbl is called `storm.group`.

```{r}
storm.group <- storm.clean %>% 
        group_by(date, event, state) %>% 
        summarize(all.fatalities = sum(fatalities),
                  all.injuries = sum(injuries),
                  all.prop.dmg = sum(prop.dmg),
                  all.crop.dmg = sum(crop.dmg),
                  all.dmg = all.prop.dmg + all.crop.dmg)

reported.events <- nrow(storm.clean)
grouped.events <- nrow(storm.group)
```

There are `r reported.events` events recorded in the data set, but after grouping, I see there are `r grouped.events`. If events were grouped by neighboring state, this figure would likely decrease even more.

### Results
With the data cleaned and tidyed, I begin the analysis by identifying the weather events that are the most hazardous to human health. It is done by summing the injuries and fatalities. In addition, I will count the number of events.

```{r}
hazard.health <- storm.group %>%
        group_by(event) %>%
        summarize(total.fatalities = sum(all.fatalities),
                  total.injuries = sum(all.injuries),
                  count = n(),
                  fatalities.per.event = round(total.fatalities/count, 1),
                  injuries.per.event = round(total.injuries/count), 1) %>%
        arrange(desc(fatalities.per.event))

head(hazard.health, 5)
```

Looking at the events that cause the most loss of life, the top five are

1. Tsunami
2. Excessive Heat
3. Rip Currents
4. Hurricanes
5. Avalanche

I note that tsunamis were infrequent, only 10 recorded in the 21 years of the data set. Excessive heat and rip current were both deadly and common.

I can arrange the table and consider the number of injuries per event.

```{r}
head(arrange(hazard.health, desc(injuries.per.event)), 5)
```

As before, tsunamis have the greatest impact on human health, and heat, in its two designations, are placed similar to before. Under this metric, the effect of hurricanes and tornados are seen.

Turning my attention to the damage caused by storms, I can perform an opperation like that before. I create a new data frame tbl `most.cost`, which summarizes the total property, crop, and overall damage.

```{r}
most.cost <- storm.group %>%
        group_by(event) %>%
        summarize(total.prop.dmg = sum(all.prop.dmg),
                  total.crop.dmg = sum(all.crop.dmg),
                  count = n(),
                  prop.dmg.per.event = round(total.prop.dmg/count, 1),
                  crop.dmg.per.event = round(total.crop.dmg/count, 1),
                  total.cost.per.event = prop.dmg.per.event + crop.dmg.per.event) %>%
        arrange(desc(total.cost.per.event)) %>%
        select(event, total.cost.per.event, count, 2, 3, 5, 6)

head(most.cost, 5)
```

Hurricanes and storm surges rank highest and are an order of magnitude greater in their total cost per event. Tropical storms add to the cost of extreme ocean storms. Tsunamis are also ranked high. Floods rank fifth, but are approximately 50 times more common than hurricanes, storm surge, and tropical storms. 

#### Differences across states

```{r}
state.health <- storm.group %>%
                group_by(state, event) %>%
                summarize(total.fatalities = sum(all.fatalities),
                          total.injuries = sum(all.injuries),
                          count = n(),
                          fatalities.per.event = round(total.fatalities/count, 1),
                          injuries.per.event = round(total.injuries/count), 1)

state.cost <- storm.group %>%
                group_by(state, event) %>%
                summarize(total.prop.dmg = sum(all.prop.dmg),
                          total.crop.dmg = sum(all.crop.dmg),
                          count = n(),
                          prop.dmg.per.event = round(total.prop.dmg/count, 1),
                          crop.dmg.per.event = round(total.crop.dmg/count, 1),
                          total.cost.per.event = prop.dmg.per.event + crop.dmg.per.event)

state.results <- cbind(state.abb, matrix(rep('', 150), ncol = 3))

for (row in 1:nrow(state.results)) {
        state.name <- as.character(state.results[row, 1])
        temp.health <- filter(state.health, state == state.name)
        temp.cost <- filter(state.cost, state == state.name)
        max.fatal.index <- which.max(temp.health$fatalities.per.event)
        max.injury.index <- which.max(temp.health$injuries.per.event)
        max.cost.index <- which.max(temp.cost$total.cost.per.event)
        state.results[row, 2] <- as.character(temp.health$event[[max.fatal.index]])
        state.results[row, 3] <- as.character(temp.health$event[[max.injury.index]])
        state.results[row, 4] <- as.character(temp.cost$event[[max.cost.index]])
}

state.results <- as.data.frame(state.results)
names(state.results) <- c('state', 'fatalities.per.event', 'injuries.per.event', 
                          'total.cost.per.event')
```


