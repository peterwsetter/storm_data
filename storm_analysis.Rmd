---
title: "Analysis of the Effects of Storms on Population Health"
author: "Peter W Setter"
date: "March 6, 2015"
output: html_document
---

### Synopsis


### Questions
Across the United States, which types of events (as indicated in the EVTYPE variable) are most harmful with respect to population health?

Across the United States, which types of events have the greatest economic consequences?

### Data Processing

```{r, cache=TRUE}
library(R.utils)
library(dplyr)
library(stringr)
storm.data.url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
download.file(storm.data.url, destfile = "StormData.csv.bz2", method = "curl")
Sys.time() # Time of downloading data
bunzip2(filename = "StormData.csv.bz2")
storm.data <- tbl_df(read.csv("StormData.csv", header=TRUE))
```

With the data load, my next steps will involve cleaning and tidying it. I'll start with several basic tasks:

* Turn all the `EVTYPE` factors to lower case
* Convert the `BGN_DATE` from a factor into `POSIXct` format
* Create `prop.dmg`, which multiplies `PROPDMG` by `PROPDMGEXP` to give the property damage in dollars (This ensures the variable is in one column rather than two)
* Create `crop.dmg`, which multiples `CROPDMG` by `CROPDMGEXP` to give the property damage in dollars (Again, isolating the variable to one column)
* Selecting the columns of interest for this study -- date, state, injuries, fatalities, and damage costs -- while tidying the column names by changing them to lower case
* Filtering the results for events in 1996 and later

The final step was performed because the data prior to this date is (more complete)[https://class.coursera.org/repdata-012/forum/thread?thread_id=29#comment-28]. Given the size of storm.data, we will remove it to free up resources.

```{r}
storm.data2 <- storm.data %>%  
        mutate(event = tolower(EVTYPE), 
               date = mdy_hms(BGN_DATE),
               prop.dmg = ifelse(PROPDMGEXP == 'K', PROPDMG*1000,
                                  ifelse(PROPDMGEXP == 'M', PROPDMG*1e6,
                                        ifelse(PROPDMGEXP == 'B', PROPDMG*1e9, 0))),
               crop.dmg = ifelse(CROPDMGEXP == 'K', CROPDMG*1000,
                                  ifelse(CROPDMGEXP == 'M', CROPDMG*1e6,
                                        ifelse(CROPDMGEXP == 'B', CROPDMG*1e9, 0)))) %>% 
        select(date, event, state = STATE, fatalities = FATALITIES, 
               injuries = INJURIES, prop.dmg, crop.dmg) %>% 
        filter(date > ymd('1995-12-31'))
rm(storm.data)
```

Looking at the structure of `storm.data2` we see that there are many more events in the data set than the 48 mentioned in the documentation. 

```{r}
str(storm.data2)
```

The next task will be to clean the data by combing factors so they fall within the permitted categories. If the listing is unknown or difficult to determine, it will be placed in the category `other`. `Combine.events` is a function that returns a permitted event name based on on an `event`. By coupling `any` with `str_detect`, we can look for abbreviations and misspellings, e.g. "tstm" for "thunderstorm" and "wnd" for "wind".

With the function defined, I utilize vapply to create a new column, `clean.event`, with each `event` properly classified. Please see this [StackOverflow post](http://stackoverflow.com/questions/9668456/why-does-sapply-return-a-list) for an explanation on the use of vapply.

```{r}
Combine.events <- function(event) {
        if(str_detect(event, 'marine')) {
                
        } else if (any(str_detect(event, 
                        c('winter storm', 'ice storm', 'snow squall')))) {
                return('winter.storm')
        } else if(any(str_detect(event, 
                        c('flurries', 'icy', 'mixed',
                          'freezing', 'wintry')))) {
                return('winter.weather')
        } else if (str_detect(event, 'sleet')) {
                return('sleet')
        }
        
        else if (any(str_detect(event, 
                        c('freeze', 'frost', 'glaze', 'black ice')))) {
                return('frost.freeze')
        } else if (str_detect(event, 'tropical')) {
                if (str_detect(event, 'storm')) {
                        return('tropical.storm')
                } else {
                        return('tropical.depression')
                }
        } else if (any(str_detect(event, c('hurricane', 'typhoon')))) {
                return('hurricane.typhoon')
        } else if (str_detect(event, 'surf')) {
                return('high.surf')
        }
        
        else if (str_detect(event, 'tornado')) {
                return('tornado')       
        } else if (str_detect(event, 'spout')) {
                return('waterspout')
        } else if (any(str_detect(event, c('funnel', 'whirl', 'wall')))) {
                return('funnel.cloud')
        }
        
        else if (str_detect(event, 'hail')) {
                return('hail')
        } 
         else if (str_detect(event, 'snow')) {
                if (any(str_detect(event, c('heavy', 'snow')))) {
                        return('heavy.snow')
                } else {
                        return('winter.weather')
                }
        }
        
        else if (any(str_detect(event, c('flood', 'fld', 'beach', 'jam')))) {
                if (any(str_detect(event, c('costal', 'cstl', 'tidal', 'beach')))) {
                        return('costal.flood')
                } else if (str_detect(event, 'flash')) {
                        return('flash.flood')
                } else if (str_detect(event, 'lake')) {
                        return('lakeshore.flood')
                } else {
                        return('flood')
                }
        } else if (any(str_detect(event, c('mud', 'slump')))) {
                return('debris.flow')
        }
        
        else if (any(str_detect(event, c('freezing')))) {
                return('winter.weather')
        } else if (any(str_detect(event, c('cold', 'chill')))) {
                if (any(str_detect(event, 
                        c('extreme', 'record', 'excessive', 'extended')))) {
                        return('extreme.cold.wind.chill')
                } else {
                        return('cold.wind.chill')
                }
        } else if (any(str_detect(event, c('heat', 'warm')))) {
                if(any(str_detect(event, c('excessive', 'record')))) {
                        return('excessive.heat')
                } else {
                        return('heat')
                }
        } else if (str_detect(event, 'light')) {
                return(lightning)
        } else if (str_detect(event, 'blizzard')) {
                return('blizzard')
        } else if (str_detect(event, 'avalanc')) {
                return('avalanche')
        }
        
        else if (str_detect(event, 'rip')) {
                return('rip.current')
        } else if (str_detect(event, 'surge')) {
                return('storm.surge')
        }
        
        else if (any(str_detect(event, c('drought', 'record dry', 'hot and dry')))) {
                return(drought)
        } else if (str_detect(event, 'fire')) {
                return('wildfire')
        } else if (str_detect(event, 'dust')) {
                if (str_detect(event, 'devil')) {
                        return('dust.devil')
                } else {
                        return('dust.storm')
                }
        }
        
        else if (any(str_detect(event, c('wind', 'wnd', 'burst')))) {
                if(any(str_detect(event, c('tstm', 'thunderstorm', 'burst')))) {
                        return('thunderstorm.wind')
                } else if(str_detect(event, 'high') {
                        return('high.wind')
                } else {
                        return('strong.wind')
                } 
        } else if (str_detect(event, 'fog')) {
                if (any(str_detect(event, c('freezing', 'ice')))) {
                        return('freezing.fog')
                } else {
                        return('dense.fog')
                }
        } else if (str_detect(event, 'volcan')) {
                return('volcanic.ash')
        } else if (any(str_detect(event, 
                        c('rain', 'thunderstorms', 'coastal storm', 
                          'wet month',
                          'precipitaiton')))) {
                return('heavy.rain')
        } else if (any(str_detect(event, c('blow-out', 'astronomical low'))) {
                return('astronomical.low.tide')
        }
}

vapply(storm.subset$event, Combine.events, character(1))
```

If we examine the head of the data frame tbl, we notice that there are several entries that have the same `date`, `event`, and `state`. 

Large events can affect sevearl parts of a state or multiple states. Each county or region may report separately. To best understand each event, we can group the data by `date`, `event`, and `state`, and then report the number of counties affected, the total property damage, the total crop damage, the total damage, total fatalities, and total injuries. We chose to group by state, because diaster relief is typically performed at the state level with potential federal support.

### Results
